# Docker Guide

Docker is a platform for developing, shipping, and running applications in containers. Containers package software with all its dependencies, ensuring consistency across different environments.

## What are Containers?

Containers are lightweight, standalone, executable packages that include everything needed to run software: code, runtime, system tools, libraries, and settings.

### Containers vs Virtual Machines

**Containers**:
- Share the host OS kernel
- Lightweight (MBs in size)
- Start in seconds
- Better resource utilization

**Virtual Machines**:
- Include full OS
- Heavy (GBs in size)
- Start in minutes
- More isolation but higher overhead

## Docker Images

An image is a read-only template with instructions for creating a Docker container. Images are built from a Dockerfile and can be stored in registries like Docker Hub.

### Image Layers

Docker images are built in layers. Each instruction in a Dockerfile creates a new layer. Layers are cached and reused, making builds faster.

```dockerfile
FROM python:3.11-slim      # Base layer
WORKDIR /app               # Layer 2
COPY requirements.txt .    # Layer 3
RUN pip install -r requirements.txt  # Layer 4
COPY . .                   # Layer 5
CMD ["python", "app.py"]   # Layer 6
```

## Dockerfile

A Dockerfile is a text file containing instructions for building a Docker image.

### Common Dockerfile Instructions

**FROM**: Specifies the base image
```dockerfile
FROM ubuntu:22.04
FROM python:3.11-slim
```

**WORKDIR**: Sets the working directory
```dockerfile
WORKDIR /app
```

**COPY**: Copies files from host to container
```dockerfile
COPY . /app
COPY requirements.txt .
```

**RUN**: Executes commands during build
```dockerfile
RUN apt-get update && apt-get install -y curl
RUN pip install flask
```

**ENV**: Sets environment variables
```dockerfile
ENV PORT=8000
ENV PYTHONUNBUFFERED=1
```

**EXPOSE**: Documents which ports the container listens on
```dockerfile
EXPOSE 8000
```

**CMD**: Specifies the default command to run
```dockerfile
CMD ["python", "app.py"]
CMD ["uvicorn", "main:app", "--host", "0.0.0.0"]
```

**ENTRYPOINT**: Configures container as an executable
```dockerfile
ENTRYPOINT ["python"]
CMD ["app.py"]  # Can be overridden
```

### Best Practices

1. Use specific image tags, not `latest`
2. Minimize the number of layers
3. Use `.dockerignore` to exclude unnecessary files
4. Run as non-root user when possible
5. Use multi-stage builds to reduce image size

## Docker Compose

Docker Compose is a tool for defining and running multi-container Docker applications using a YAML file.

### docker-compose.yml Example

```yaml
version: '3.8'

services:
  web:
    build: .
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://db:5432/myapp
    depends_on:
      - db
    volumes:
      - ./data:/app/data

  db:
    image: postgres:15
    environment:
      - POSTGRES_PASSWORD=secret
      - POSTGRES_DB=myapp
    volumes:
      - postgres_data:/var/lib/postgresql/data

volumes:
  postgres_data:
```

### Docker Compose Commands

```bash
# Start services
docker-compose up

# Start in detached mode
docker-compose up -d

# Build images before starting
docker-compose up --build

# Stop services
docker-compose down

# View logs
docker-compose logs -f

# Execute command in running container
docker-compose exec web bash

# Scale a service
docker-compose up --scale web=3
```

## Volumes

Volumes are the preferred mechanism for persisting data generated by containers. They are managed by Docker and stored outside the container filesystem.

### Types of Volumes

**Named Volumes**: Managed by Docker
```yaml
volumes:
  my_data:

services:
  app:
    volumes:
      - my_data:/app/data
```

**Bind Mounts**: Mount host directory
```yaml
services:
  app:
    volumes:
      - ./local_folder:/app/data
      - /var/run/docker.sock:/var/run/docker.sock
```

**Anonymous Volumes**: Created without a name
```yaml
services:
  app:
    volumes:
      - /app/temp
```

## Networks

Docker networks enable communication between containers.

### Network Types

**Bridge**: Default network for containers on same host
**Host**: Container shares host network stack
**Overlay**: Multi-host networking for swarm services
**None**: Disable networking

### Custom Networks

```yaml
networks:
  frontend:
  backend:

services:
  web:
    networks:
      - frontend
      - backend
  db:
    networks:
      - backend
```

## Docker Commands

### Container Management

```bash
# Run a container
docker run -d -p 8000:8000 --name myapp myimage

# List running containers
docker ps

# List all containers
docker ps -a

# Stop a container
docker stop myapp

# Remove a container
docker rm myapp

# View container logs
docker logs -f myapp

# Execute command in container
docker exec -it myapp bash
```

### Image Management

```bash
# Build an image
docker build -t myapp:v1 .

# List images
docker images

# Remove an image
docker rmi myapp:v1

# Pull an image
docker pull nginx:latest

# Push to registry
docker push myregistry/myapp:v1

# Tag an image
docker tag myapp:v1 myapp:latest
```

### System Management

```bash
# Remove unused data
docker system prune

# Remove all stopped containers
docker container prune

# Remove unused images
docker image prune

# View disk usage
docker system df
```

## Multi-Stage Builds

Multi-stage builds help create smaller production images by separating build and runtime dependencies.

```dockerfile
# Build stage
FROM node:16 AS builder
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build

# Production stage
FROM node:16-slim
WORKDIR /app
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/node_modules ./node_modules
CMD ["node", "dist/main.js"]
```

This approach keeps build tools out of the final image, significantly reducing its size.

## Health Checks

Health checks allow Docker to test if a container is working correctly.

```dockerfile
HEALTHCHECK --interval=30s --timeout=3s --retries=3 \
  CMD curl -f http://localhost:8000/health || exit 1
```

```yaml
services:
  web:
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
```

Docker is an essential tool in modern software development, enabling consistent deployments across development, testing, and production environments.
